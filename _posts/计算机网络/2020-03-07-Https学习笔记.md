---
title: "Https学习笔记"
date: 2020-03-07 09:30:08 +0800
category: [学习笔记]
tags: [Network, Notes]
comment: false
reward: true
excerpt: 学习Https的相关知识。
---

# Https简介
HTTPS （全称：**Hyper Text Transfer Protocol over SecureSocket Layer**），是**以安全为目标的 HTTP 通道**，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在HTTP 的基础下加入**SSL** 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 TCP 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面。

# Http的缺点
HTTP 协议虽然使用极为广泛, 但是却存在不小的安全缺陷, 主要是其数据的**明文传送**和消息完整性检测的缺乏, 而这两点恰好是网络支付, 网络交易等新兴应用中安全方面最需要关注的 。  
关于 HTTP协议的明文数据传输, 攻击者最常用的攻击手法就是网络嗅探, 试图从传输过程当中分析出敏感的数据, 例如管理员对 Web 程序后台的登录过程等等, 从而获取网站管理权限, 进而渗透到整个服务器的权限。即使无法获取到后台登录信息, 攻击者也可以从网络中获取普通用户的隐秘信息, 包括手机号码, 身份证号码, 信用卡号等重要资料, 导致严重的安全事故。进行网络嗅探攻击非常简单, 对攻击者的要求很低。使用网络发布的任意一款抓包工具, 一个新手就有可能获取到大型网站的用户信息。  
另外,HTTP协议在传输客户端请求和服务端响应时, **唯一的数据完整性检验就是在报文头部包含了本次传输数据的长度,** **而对内容是否被篡改不作确认**。 因此攻击者可以轻易的发动中间人攻击, 修改客户端和服务端传输的数据, 甚至在传输数据中插入恶意代码, 导致客户端被引导至恶意网站被植入木马。  


# Https和Http的区别和联系
1. https协议需要到**ca申请证书**，一般免费证书较少，因而需要一定费用。
2. http是超文本传输协议，信息是**明文传输**，https则是具有安全性的**ssl加密传输协议**。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是**80**，后者是**443**。
4. http的连接很简单，是**无状态**的；HTTPS协议是由SSL+HTTP协议构建的可进行**加密传输**、**身份认证**的网络协议，比http协议安全。

# Http工作流程
1. 建立TCP/IP连接，客户端与服务器通过**Socket**三次握手进行连接

2. 客户端向服务端发起HTTP请求（例如：POST/login.html http/1.1）

3. 客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕

4. 服务器做出应答，表示对于客户端请求的应答，例如：HTTP/1.1 200 OK

5. 服务器向客户端发送应答头信息

6. 服务器向客户端发送请求头信息后，也会发送一空白行，标示应答头信息发送完毕，接着就以Content-type要求的数据格式发送数据给客户端

7. 服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接


# Https工作流程
1. 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。

2. Web服务器收到客户端请求后，会将网站的**证书信息**（证书中**包含公钥**）传送一份给客户端。

3. 客户端的浏览器与Web服务器开始协商SSL连接的**安全等级**，也就是信息加密的等级。

4. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。

5. Web服务器利用自己的**私钥**解密出会话密钥。

6. Web服务器利用会话密钥加密与客户端之间的通信。

# Https加密流程
## 对称加密与非对称加密（转）

https://www.cnblogs.com/fengf233/p/11775415.html

对称加密：编解码使用密钥相同的算法，一般是共享密钥

![img](https://img2018.cnblogs.com/blog/1685507/201911/1685507-20191101102728226-961172709.png)

非对称加密：非对称加密算法需要两个密钥，公钥和私钥。公钥和私钥是一对，用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法

![img](https://img2018.cnblogs.com/blog/1685507/201911/1685507-20191101103037077-1478751442.png)

在Https下，这两种加密方式混合使用

![img](https://img2018.cnblogs.com/blog/1685507/201911/1685507-20191101104105058-2077044780.png)

数字证书认证 

由于公钥在下发的时候也容易被替换劫持，所以需要第三方认证机构确认公钥的正确性

CA：数字证书认证机构，是客户端服务端都认可的第三方机构，负责数字签名服务端公钥

数字签名：签名就是一种证明身份的机制，是一种校验机制（简单说就是私钥加密内容的hash，公钥解密对比hash判断内容是否完整）

数字证书：由一个可信的组织验证和签发的识别信息

Https中数字认证流程如下：

![Https访问流程图解1](https://img2018.cnblogs.com/blog/1685507/201911/1685507-20191101132559652-1495242555.png)

Https握手过程

<img src="https://img2018.cnblogs.com/blog/1685507/201910/1685507-20191031174134890-820879603.png" alt="img"  />

- Client Hello:握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 Random1、客户端支持的加密套件（Support Ciphers）和 SSL Version 等信息
- Server Hello:第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 Random2。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。
- Certificate:这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥
- Server Hello Done:通知客户端 Server Hello 过程结束。
- Certificate Verify:客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 Random3，再用服务端公钥非对称加密 Random3生成 PreMaster Key
- Client Key Exchange:上面客户端根据服务器传来的公钥生成了 PreMaster Key，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 PreMaster Key 得到客户端生成的 Random3。至此，客户端和服务端都拥有 Random1 + Random2 + Random3，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。
- Change Cipher Spec(Client):这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息
- Encrypted Handshake Message(Client):这一步对应的是 Client Finish 消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的
- Change Cipher Spec(Server):这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息
- Encrypted Handshake Message(Server):这一步对应的是 Server Finish 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。
- Application Data:到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输